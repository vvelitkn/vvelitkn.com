title: "Assembly Code Patterns and Tricks For Reverse Engineering/Malware Analysis"
classes: wide
header:
teaser: /assets/images/Malware-Analysis/Assembly-Code-Patterns-and-Tricks/logo.png
ribbon: Purple
description: "Command and control servers are the primary tools cyber threat actors have in their arsenal to launch and control cyber-attacks. C2 servers operated ..."
toc: true
categories:

- Malware Analysis

---

For most cases we have to investige assembly code of the software we analyzing and recognize the patterns for most common code blocks to understand better. Thus in this article, most common code blocks' assembly representions and some of the functions for C programming language will be discussed.

## Loops

Loops executes a block of code till condition is met. We know two common loop types: while and for.

For loop contains three statements:

- initialization part is executed one time before execution of the code block
- condition part defines the contidition for executing the code block
- update_statement is executed every time after the code block has been executed.

```
C programming language

for (initialization; condition; update_statement ) {
 // code block to be executed
}
```

```
C programming language example

#include <sys/syscall.h>

for (int i=1; i<10; i++ ) {
    syscall(4, STDOUT_FILENO, i, sizeof(i)-1);
}
```

While loop contains one statements:

- condition part defines the contidition for executing the code block

```
C programming language

while (condition) {
// code block to be executed
}
```

```
C programming language example

#include <sys/syscall.h>
int i =0;
while (i<10 ) {
    syscall(4, STDOUT_FILENO, i, sizeof(i)-1);
    i++
}
```

```
Assembly X86 instruction set

section	.text
   global _start            ;must be declared for using gcc

_start:	                    ;tell linker entry point
   mov rcx, 10              ;loop runs until the value of rcx is 0
   mov rax, '1'		    ;rax holds the character that needs to be printed

l1:			    ;loop starts
   mov [num], rax	    ;value in rax moved to variable num
   mov rax, 4		    ;4 is the system call number for the WRITE system call
   mov rbx, 1		    ;1 is the file descriptor for the output stream
   push rcx		    ;value of rcx pushed to stack and stored here temporarily

			    ;rbx, rcx and rdx are arguments to the write system call

   mov rcx, num             ;num moved to rcx, as rcx contains the character that will be printed
   mov rdx, 1       	    ;1 is the size (1 byte) of the character that is to be printed
   int 0x80		    ;interrupt that executes the write system call in kernel mode

   mov rax, [num]	    ;the first character has been output, value of num moved to eax
   sub rax, '0'		    ;converts character in eax to decimal
   inc rax		    ;increments decimal value in eax by 1
   add rax, '0'		    ;converts decimal back to character
   pop rcx		    ;pops back value of ecx temporarily stored on the stack
   loop l1                  ;loops, value of ecx auto decremented

   mov eax,1                ;system call number (sys_exit)
   int 0x80                 ;call kernel
section	.bss
num resb 1
```

Output: 123456789

* The`rax` register stores the iteration number, and the`rcx` register stores the total number of iterations and is initialized to 10.
* The`l1` block represents the loop code. At each iteration, the iteration count in the`rcx` register is pushed onto the stack. The current value of`rax` is moved to`rcx`, and a write system call is made, which prints the number on the screen.
* `rax` is incremented, and the iteration count is popped from the stack into the`rcx` register. The program then decrements`rcx` and jumps to`l1` using the`loop` command if`rcx` is greater than 0.,

### Popular C Functions

This part contains only source codes taken from gcc's official library of popular C functions, when you understand the pattern of the function you can identify

#### memcpy()

```
Source code of memcpy()

#include <stddef.h>

void *
memcpy (void *dest, const void *src, size_t len)
{
  char *d = dest;
  const char *s = src;
  while (len--)
    *d++ = *s++;
  return dest;
}
```
#### memmove()

```
Source code of memmove()

#include <stddef.h>

void *
memmove (void *dest, const void *src, size_t len)
{
  char *d = dest;
  const char *s = src;
  if (d < s)
    while (len--)
      *d++ = *s++;
  else
    {
      char *lasts = s + (len-1);
      char *lastd = d + (len-1);
      while (len--)
        *lastd-- = *lasts--;
    }
  return dest;
}
```
#### memcmp()

```
Source code of memmcmp()

#include <stddef.h>

int
memcmp (const void *str1, const void *str2, size_t count)
{
  const unsigned char *s1 = str1;
  const unsigned char *s2 = str2;

  while (count-- > 0)
    {
      if (*s1++ != *s2++)
	  return s1[-1] < s2[-1] ? -1 : 1;
    }
  return 0;
}
```
### Popular Windows Funtions seen in Malware Samples

This part contains only Microsoft Windows API references which seen in most cases analyzing good/bas/unknown binaries/DLLs staticly.

#### Memory allocation functions

This function allocates a block of memory from heap, the allocated memory is not movable. Commonly used to allocate a memory for creating a storage for decrypted data, payload. When you follow a DLL dropper or loader kinda malware's code which includes a big .text section with random text HeapAlloc() or VirtualAlloc() function can be seen with own source code. HeapAlloc function allocates in own process but VirtualAlloc() function allocates memory in the address space of anotherprocess

Sources:
- https://github.com/gcc-mirror/gcc
- https://www.educative.io/answers/what-are-loops-in-assembly-language

